<!DOCTYPE html>
<head>
<meta charset="utf-8">
<link rel="shortcut icon" href="/favicon.ico"/>
<link rel="bookmark" href="/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="css/style.css" />
<script type="text/javascript" src="js/functions.js"></script>
<script src="d3/d3.v3.min.js"></script>
</head>

<body>
<form>
    &nbsp;请选择功能：
    <select class="btn btn-radius btn-primary" name="chooseFunction" onchange="checkField(this.selectedIndex)">
      <option value="最短路径" selected="ture">最短路径</option>
      <option value="最小生成树">最小生成树</option>
      <option value="中心度">中心度</option>
      <option value="联通分量">连通分量</option>
    </select>
</form><br/>
  <div class="form">
    <div id="path" style="style:block">
    
    
      起点：<input type="number" class="source" value="0" min="0" max="199" />
      终点：<input type="number" class="target" value="1" min="0" max="199" />
            <input type="button" value="确定" onclick="path_display()" autofocus="autofocus" /><br/>
      权值：<output type="text" value="0" class="centrality_show" id="view_weight" /> 
    </div>

    <div id="mst" style="display:none;">
      根节点：<input type="number" class="root" value="0" min="0" max="199" onchange="mst_display()"/><br/>
      <input class="Threshold" id="Threshold_tree" type="range" min="0" max="35" step="0.01" value="0" onchange="Threshold_changed_tree()" />
      <input class="Threshold_input" id="Threshold_input_tree" type="number" min="0" max="35" step="1" value="0" onchange="Threshold_input_changed_tree()" /><br/>
      权值：<output type="number" value="0" class="view_weight" id="view_tree_weight" >
    </div>

    <div id="centrality" style="display:none;">
      <input type="button" value="介数中心度" onclick="betweenness_centrality_display()" autofocus="autofocus"/>
      <input type="button" value="紧密中心度" onclick="closeness_centrality_display()" /><br/>
      中心度类型：<output type="text" value="介数中心度" class="centrality_type_show" id="centrality_type_show" /> 
    </div>

    <div id="connected_component" style="display:none;">
           <input class="Threshold" id="Threshold" type="range" min="0" max="35" step="0.01" value="0" onchange="Threshold_changed()" />
           <input class="Threshold_input" id="Threshold_input" type="number" min="0" max="35" step="1" value="0" onchange="Threshold_input_changed()" />
    </div>
  </div>
  <div class="svg"></div>           
</body>

<script>
var width = 1366,
    height = 600;
var color = d3.scale.category20();
var force = d3.layout.force()
    .charge(-100)
    .linkDistance(100)
    .gravity(0.1)
    .linkStrength(1)
    .size([width, height]);
var svg = d3.select(".svg").append("svg")
    .attr("x", 0)
    .attr("y", -60)
    .attr("width", width)
    .attr("height", height);
//link指向实际画出来的那些边
var link;
//edges是一个二维数组，储存领接矩阵
var edges;
var dists;
var paths;
//node指向实际上画出来的那些点
var node;
var n;
var graph_global;
d3.json("data/graph.json", function(error, graph) {
  if (error) throw error;
  graph_global = graph;
  force
      .nodes(graph.nodes)
      .links(graph.links)
      .start();
  //首先加入“边”
  n = graph.nodes.length;
  edges = new Array(n);   //先声明一维
  dists = new Array(n);
  paths = new Array(n);
  for(var k = 0; k < n; k ++)
  { 
    edges[k] = new Array(n); 
    dists[k] = new Array(n);
    paths[k] = new Array(n);
    for(var j=0;j<n;j++)
    {
      edges[k][j] = Number.POSITIVE_INFINITY;
      dists[k][j] = (k == j ? 0 : Number.POSITIVE_INFINITY);
      //paths[k][j] = Number.POSITIVE_INFINITY;
      //paths[k][j] = j;
    }
  }
  link = svg.selectAll(".link")
      .data(graph.links)
    .enter().append("line")
      .attr("class", "link")
      //为了方便查询，此处将边的id设为source.index*n+target.index。
      //其中n为节点的size，此处为200
      .attr("id", function(d){
        edges[d.source.index][d.target.index] = d.weight;
        dists[d.source.index][d.target.index] = d.weight;
        edges[d.target.index][d.source.index] = d.weight;
        dists[d.target.index][d.source.index] = d.weight;
        return (d.source.index*n+d.target.index).toString()+"_link";
      });
  link_init();
  for(var i = 0; i < n; i ++)
  for(var j = 0; j < n; j ++)
  {
    if(edges[i][j] != Number.POSITIVE_INFINITY){  
      paths[i][j] = j;  
    }
    else
    {  
      paths[i][j] = -1;  
    } 
  }  
  //使用flolyd-warshall算法计算任意两点之间的最短距离和最短路径
  for(var k = 0; k < n; k ++)
  {
    for(var i = 0; i < n; i ++)
    {
      for(var j = 0; j < n; j ++)
      {
        if(dists[i][k] != Number.POSITIVE_INFINITY 
          && dists[k][j] != Number.POSITIVE_INFINITY 
          && dists[i][k]+dists[k][j]<dists[i][j])
        {
          dists[i][j] = dists[i][k]+dists[k][j];
          // paths[i][j] = k;
          paths[i][j]=paths[i][k];
        }
      }
    }
  }
  //其次加入“点”
  node = svg.selectAll(".node")
      .data(graph.nodes)
    .enter().append("circle")
      .attr("class", "node")
      //将点的id设置为点的index。
      .attr("id", function(d){return d.index.toString()+"_node";})
      .call(force.drag);
  
  
  link.append("title")
      .text(function(d) {return "source:" + d.source.index + "\ntarget:" + d.target.index + "\nweight:" + d.weight;});
  node.append("title")
      .text(function(d) { return d.name; });
  force.on("tick", function() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });
    node.attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
  });
});
</script>